# shellcheck shell=sh

perrorf ()
{
    # Simple function for outputting error messages.
    # Prefixes the error message with the name of the utility.

    # Parameters:   same as printf
    # stdin:        unused
    # stdout:       unused
    # stderr:       error message

    _fmt=$1; shift

    # We mimic printf here, disable shellcheck warnings about using
    # variables in the printf format string.
    # See https://unix.stackexchange.com/questions/438694
    # shellcheck disable=SC2059
    printf "$UTILITY_NAME: error: $_fmt" "$@" >&2
    unset _fmt
}

pinfof ()
{
    # Same as above, but with 'info:' instead of 'error:'.
    # Also disables output if given the option -q.

    _quiet=false

    OPTIND=1
    while getopts 'q' _opt; do
        case $_opt in
            q)
                _quiet=true
                ;;
            *)
                command_line_error
                exit 1
        esac
    done
    shift "$(( OPTIND - 1 ))"

    _fmt=$1; shift

    if ! "$_quiet"; then
        # shellcheck disable=SC2059
        printf "$UTILITY_NAME: info: $_fmt" "$@" >&2
    fi

    unset _fmt
    unset _quiet
    unset _opt
}

output_version ()
{
    # Simple function for outputting version information.

    # Parameters:   none
    # stdin:        unused
    # stdout:       unused
    # stderr:       version information

    pinfof 'Part of %s (release "%s")\n' "@PACKAGE_NAME@" "@PACKAGE_VERSION@"
    pinfof 'For bug reports, see %s\n' "@PACKAGE_BUGREPORT@"
}

command_line_error ()
{
    perrorf 'Error while parsing the cammond line arguments\n'
}

# We expect that $UTILITY_NAME is set and non-empty.
if [ -z "$UTILITY_NAME" ]; then
    UTILITY_NAME="@PACKAGE_NAME@"
    perrorf 'shell-common.shlib not loaded properly\n'
    exit 1
fi

# vim: ft=sh
